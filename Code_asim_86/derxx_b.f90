!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3342) - 27 Jan 2010 15:25
!
!  Differentiation of derxx in reverse (adjoint) mode:
!   gradient     of useful results: tx ux
!   with respect to varying inputs: ux
!
!********************************************************************
!
SUBROUTINE DERXX_B(tx, txb, ux, uxb, sfx, ssx, swx, nx, ny, nz, npaire)
!-----------------------------------------------
!   M o d u l e s 
!-----------------------------------------------
  USE paramx_m 
  USE derivex_m 
  implicit none
!-----------------------------------------------
!   D u m m y   A r g u m e n t s
!-----------------------------------------------
  INTEGER, INTENT(IN) :: nx
  INTEGER, INTENT(IN) :: ny
  INTEGER, INTENT(IN) :: nz
  INTEGER, INTENT(IN) :: npaire
  REAL*8, INTENT(INOUT) :: tx(nx, ny, nz)
  REAL*8 :: txb(nx, ny, nz)
  REAL*8, INTENT(IN) :: ux(nx, ny, nz)
  REAL*8 :: uxb(nx, ny, nz)
  REAL*8, INTENT(IN) :: sfx(nx)
  REAL*8, INTENT(IN) :: ssx(nx)
  REAL*8, INTENT(IN) :: swx(nx)
!-----------------------------------------------
!   L o c a l   V a r i a b l e s
!-----------------------------------------------
  INTEGER :: k, j, i
  REAL*8 :: tempb0
  REAL*8 :: tempb
!-----------------------------------------------
!
!********************************************************************
!
  print *
  IF (nclx .EQ. 2) THEN
    DO i=1,nx-1,1
      DO k=nz,1,-1
        DO j=ny,1,-1
          txb(i+1, j, k) = txb(i+1, j, k) - swx(i)*sfx(i)*txb(i, j, k)
          txb(i, j, k) = swx(i)*txb(i, j, k)
        END DO
      END DO
    END DO
    DO k=nz,1,-1
      DO j=ny,1,-1
        txb(nx, j, k) = swx(nx)*txb(nx, j, k)
      END DO
    END DO
    DO i=nx,2,-1
      DO k=nz,1,-1
        DO j=ny,1,-1
          txb(i-1, j, k) = txb(i-1, j, k) - ssx(i)*txb(i, j, k)
        END DO
      END DO
    END DO
    DO k=nz,1,-1
      DO j=ny,1,-1
        uxb(nx, j, k) = uxb(nx, j, k) + asnx*txb(nx, j, k)
        uxb(nx-1, j, k) = uxb(nx-1, j, k) + bsnx*txb(nx, j, k)
        uxb(nx-2, j, k) = uxb(nx-2, j, k) + csnx*txb(nx, j, k)
        uxb(nx-3, j, k) = uxb(nx-3, j, k) + dsnx*txb(nx, j, k)
        txb(nx, j, k) = 0.0_8
        tempb0 = asmx*txb(nx-1, j, k)
        uxb(nx, j, k) = uxb(nx, j, k) + tempb0
        uxb(nx-1, j, k) = uxb(nx-1, j, k) - 2*tempb0
        uxb(nx-2, j, k) = uxb(nx-2, j, k) + tempb0
        txb(nx-1, j, k) = 0.0_8
      END DO
    END DO
    DO i=nx-2,3,-1
      DO k=nz,1,-1
        DO j=ny,1,-1
          uxb(i+1, j, k) = uxb(i+1, j, k) + asix*txb(i, j, k)
          uxb(i-1, j, k) = uxb(i-1, j, k) + asix*txb(i, j, k)
          uxb(i+2, j, k) = uxb(i+2, j, k) + bsix*txb(i, j, k)
          uxb(i-2, j, k) = uxb(i-2, j, k) + bsix*txb(i, j, k)
          uxb(i, j, k) = uxb(i, j, k) - (asix*2.+bsix*2.)*txb(i, j, k)
          txb(i, j, k) = 0.0_8
        END DO
      END DO
    END DO
    DO k=nz,1,-1
      DO j=ny,1,-1
        tempb = as2x*txb(2, j, k)
        uxb(3, j, k) = uxb(3, j, k) + tempb
        uxb(2, j, k) = uxb(2, j, k) - 2*tempb
        txb(2, j, k) = 0.0_8
        uxb(1, j, k) = uxb(1, j, k) + as1x*txb(1, j, k) + tempb
        uxb(2, j, k) = uxb(2, j, k) + bs1x*txb(1, j, k)
        uxb(3, j, k) = uxb(3, j, k) + cs1x*txb(1, j, k)
        uxb(4, j, k) = uxb(4, j, k) + ds1x*txb(1, j, k)
        txb(1, j, k) = 0.0_8
      END DO
    END DO
  END IF
END SUBROUTINE DERXX_B
