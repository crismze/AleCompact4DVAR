!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3342) - 27 Jan 2010 15:25
!
!  Differentiation of derx in reverse (adjoint) mode:
!   gradient     of useful results: tx ux
!   with respect to varying inputs: ux
!********************************************************************
!
SUBROUTINE DERX_B(tx, txb, ux, uxb, ffx, fsx, fwx, nx, ny, nz, npaire)
!-----------------------------------------------
!   M o d u l e s 
!-----------------------------------------------
  USE paramx_m
  USE derivex_m
  implicit none
!-----------------------------------------------
!   D u m m y   A r g u m e n t s
!-----------------------------------------------
  INTEGER, INTENT(IN) :: nx
  INTEGER, INTENT(IN) :: ny
  INTEGER, INTENT(IN) :: nz
  INTEGER, INTENT(IN) :: npaire
  REAL, INTENT(INOUT) :: tx(nx, ny, nz)
  REAL :: txb(nx, ny, nz)
  REAL*8, INTENT(IN) :: ux(nx, ny, nz)
  REAL*8 :: uxb(nx, ny, nz)
  REAL*8, INTENT(IN) :: ffx(nx)
  REAL*8, INTENT(IN) :: fsx(nx)
  REAL*8, INTENT(IN) :: fwx(nx)
!-----------------------------------------------
!   L o c a l   V a r i a b l e s
!-----------------------------------------------
  INTEGER :: k, j, i
!-----------------------------------------------
!
!********************************************************************
!
  IF (nclx .EQ. 2) THEN
    DO i=1,nx-1,1
      DO k=nz,1,-1
        DO j=ny,1,-1
          txb(i+1, j, k) = txb(i+1, j, k) - fwx(i)*ffx(i)*txb(i, j, k)
          txb(i, j, k) = fwx(i)*txb(i, j, k)
        END DO
      END DO
    END DO
    DO k=nz,1,-1
      DO j=ny,1,-1
        txb(nx, j, k) = fwx(nx)*txb(nx, j, k)
      END DO
    END DO
    DO i=nx,2,-1
      DO k=nz,1,-1
        DO j=ny,1,-1
          txb(i-1, j, k) = txb(i-1, j, k) - fsx(i)*txb(i, j, k)
        END DO
      END DO
    END DO
    DO k=nz,1,-1
      DO j=ny,1,-1
        uxb(nx, j, k) = uxb(nx, j, k) - afnx*txb(nx, j, k)
        uxb(nx-1, j, k) = uxb(nx-1, j, k) - bfnx*txb(nx, j, k)
        uxb(nx-2, j, k) = uxb(nx-2, j, k) - cfnx*txb(nx, j, k)
        txb(nx, j, k) = 0.0
        uxb(nx, j, k) = uxb(nx, j, k) + afmx*txb(nx-1, j, k)
        uxb(nx-2, j, k) = uxb(nx-2, j, k) - afmx*txb(nx-1, j, k)
        txb(nx-1, j, k) = 0.0
      END DO
    END DO
    DO i=nx-2,3,-1
      DO k=nz,1,-1
        DO j=ny,1,-1
          uxb(i+1, j, k) = uxb(i+1, j, k) + afix*txb(i, j, k)
          uxb(i-1, j, k) = uxb(i-1, j, k) - afix*txb(i, j, k)
          uxb(i+2, j, k) = uxb(i+2, j, k) + bfix*txb(i, j, k)
          uxb(i-2, j, k) = uxb(i-2, j, k) - bfix*txb(i, j, k)
          txb(i, j, k) = 0.0
        END DO
      END DO
    END DO
    DO k=nz,1,-1
      DO j=ny,1,-1
        uxb(3, j, k) = uxb(3, j, k) + af2x*txb(2, j, k)
        uxb(1, j, k) = uxb(1, j, k) - af2x*txb(2, j, k)
        txb(2, j, k) = 0.0
        uxb(1, j, k) = uxb(1, j, k) + af1x*txb(1, j, k)
        uxb(2, j, k) = uxb(2, j, k) + bf1x*txb(1, j, k)
        uxb(3, j, k) = uxb(3, j, k) + cf1x*txb(1, j, k)
        txb(1, j, k) = 0.0
      END DO
    END DO
  END IF
END SUBROUTINE DERX_B
